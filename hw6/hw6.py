import networkx as nx

path = "c_cout.dot"
ouput_file = "control_dep.dot"
magic_exit = '0x40183d'
#magic_exit = '0x40116e' # choose a arbitrary one,in this case it is where switch cases merge
#'0x401fe1' works tpp
branch_set = set()
ins_dot_set = set()

def build_dot():
    f = open("c_output.txt",'r')
    c_f= open("c_cout.dot", 'w')
    c_f.write("digraph G {\n")

    lines = f.readlines()

    for i, ins in enumerate(lines[:-1]):
        if (lines[i], lines[i+1]) not in ins_dot_set:
            c_f.write("\"{0}\"  ->  \"{1}\"\n".format(str(lines[i][:-1]), str(lines[i+1][:-1])))
            ins_dot_set.add((lines[i], lines[i+1]))
    c_f.write("}")

def get_branch_inst():
    f = open("branches.txt", "r")
    branches = f.readlines()

    branches = [x[:-1] for x in branches[:-1]]
    return set(branches)

def get_ins_trace():
    f = open("c_output.txt", "r")
    lines = f.readlines()
    lines = [x[:-1] for x in lines]
    return lines

def generate_control_dep():
    G = nx.nx_pydot.read_dot(path)
    reverse_G = G.reverse()

    IPD_dict = nx.immediate_dominators(reverse_G, magic_exit)
    CDS = list()
    instruction_trace = get_ins_trace()
    branch_set = get_branch_inst()

    o_file = open(ouput_file, 'w')
    o_file.write("digraph G {\n")
    edge_set = set()
    for i in instruction_trace:
        #i = ins[:-1]
        if len(CDS):
            if (i,CDS[-1][0]) not in edge_set:
                o_file.write("\"{0}\"  ->  \"{1}\"\n".format(i, CDS[-1][0]))
                edge_set.add((i,CDS[-1][0]))

        if i in branch_set:
            CDS.append((i,IPD_dict[i]))

        while len(CDS) != 0 and CDS[-1][1] == i:
            del CDS[-1]
    o_file.write("}")

def optimal_exit():
    instruction_trace = get_ins_trace()
    inst_trace = set(instruction_trace)
    num_ins = len(inst_trace)
    G = nx.nx_pydot.read_dot(path)
    reverse_G = G.reverse()

    ans_ins = ''
    min_diff = 100000
    for ins in inst_trace:
        IPD_dict = nx.immediate_dominators(reverse_G, ins)
        diff = num_ins - len(IPD_dict)

        if diff < min_diff:
            min_diff = diff
            ans_ins = ins

    print(f'min_diff {min_diff} ans_ins {ans_ins}')

def get_leaf_nodes():
    G = nx.nx_pydot.read_dot(path)

    for n in G.nodes():
        out = G.out_degree(n)
        if out == 0:
            print(n)
#build_dot() # call once
#optimal_exit() # call once
# get_leaf_nodes() # no leaf nodes
generate_control_dep()