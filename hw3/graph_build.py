from cProfile import label
from re import I
import idautils
import idc
import idaapi
import pickle
from typing import Dict, List, Tuple

"""

KA: Replaced multi level dict to inst_info class

visited: keeps track of block visits, using the block start address as the key
count: to have a unique id for each instruction

parent_adj: it the main data structure to store the result
<outer_key, {inner_key:[List]}>

outer_key stores the hex address corresponding to the instruction

inner_key stores the node id(instruction id)

List: stores the parent instruction id, 0th index contains the instruction in assembly

"""

class inst_info():
    def __init__(self, node_id, D_list, U_list, inst):
        self.D_list = D_list
        self.U_list = U_list
        self.inst = inst
        self.node_id = node_id
        self.parent_list = list()

def get_Defined_Used(ins):

    """
    for every operand in the instruction check if write or read flag is set.
    mark operand as used if read is set, mark it as defined if write flag is set

    Right now this doesn't take care of
    1) push/pop/ret/Call which use/modify esp
    2) cmp and jmp instruction modifying flags

    TODO: add if checks

    reference: https://reverseengineering.stackexchange.com/questions/12053/ida-generic-approach-to-determine-if-an-instruction-reads-from-or-writes-to-m
    """

    D = list()
    U = list()

    OPND_WRITE_FLAGS = {
        0: idaapi.CF_CHG1,
        1: idaapi.CF_CHG2,
        2: idaapi.CF_CHG3,
        3: idaapi.CF_CHG4,
        4: idaapi.CF_CHG5,
        5: idaapi.CF_CHG6,
    }

    OPND_READ_FLAGS = {
        0: idaapi.CF_USE1,
        1: idaapi.CF_USE2,
        2: idaapi.CF_USE3,
        3: idaapi.CF_USE4,
        4: idaapi.CF_USE5,
        5: idaapi.CF_USE6,
    }

    insn = idautils.DecodeInstruction(ins)
    feature = insn.get_canon_feature()

    for op in insn.ops:
        if op.type == idaapi.o_void:
            break

        is_write = feature & OPND_WRITE_FLAGS[op.n]
        is_read = feature & OPND_READ_FLAGS[op.n]

        if(is_write):
            D.append(idc.print_operand(ins, op.n))

        if(is_read):
            U.append(idc.print_operand(ins, op.n))

    return D,U

# Logic is mostly similar to DFS
def find_graph(block, parent, visited, parent_adj: Dict[str, inst_info], count):
    visited[block.start_ea]=1

    #First parsing current block instructions
    insts = idautils.Heads(block.start_ea, block.end_ea)

    for ins in insts:
        node_id = "n{}".format(count[0])
        parent_adj[hex(ins)] = {}
        D_list, U_list = get_Defined_Used(ins)
        parent_adj[hex(ins)] = inst_info(node_id, D_list, U_list, idc.GetDisasm(ins))
        parent_adj[hex(ins)].parent_list.append(parent)

        print("{0} [label=\"{1}; D: {2}; U: {3}\"]".format(node_id, hex(ins), D_list, U_list))
        parent = node_id
        count[0] = count[0] + 1

    # Now call for all the successive blocks
    for succ_block in block.succs():
        #print("outside",block)
        if succ_block.start_ea not in visited:
            find_graph(succ_block, parent, visited, parent_adj, count) # recursive call
        else:
            # gets_added_in_calle_first_ins_as_parent
            ins = succ_block.start_ea
            parent_adj[hex(ins)].parent_list.append(parent)
    return

def print_graph(adj_parent: Dict[str, inst_info]):

    for inst_addr in adj_parent:
        curr_node = adj_parent[inst_addr].node_id

        for parent in adj_parent[inst_addr].parent_list:
            print("{0} -> {1}".format(parent, curr_node))

def main():

    for curr_function in idautils.Functions():

        FUNCTION_NAME = idc.get_func_name(curr_function)
        print("\nCURRENT FUNCTION IS {0}".format(FUNCTION_NAME))
        for _ in range(0,2):
            print("**********************************************")
        #FUNCTION_NAME = 'start' #Change this to whatever func you want to look for. May have to change to _start in some cases or code your own logic

        print ("Start of the functions")
        cursor = 0
        real_names = []
        addresses = []

        adj_parent : Dict[str, inst_info]= {} # hex_address-->{hex addr: inst_info}
        count = [0]

        names = idautils.Names()

        # Populate the two above lists with their respective data from the list of tuples returned by idautils.Names()
        for n in names:
            real_names.append(n[1]) # real_names[30] ------> addresses[30]
            addresses.append(n[0])

        # search for a 'start' name in the names list and if it is there, set cursor to the address of beginning of it
        for rn in real_names:
            if rn == FUNCTION_NAME:
                cursor = addresses[int(real_names.index(FUNCTION_NAME))]
                break

        parent="start"
        visited={}

        if cursor: #if a start was found, assign it to the cursor and then
            myFunc = idaapi.get_func(cursor)
            f = idaapi.FlowChart(myFunc)
            for block in f:
                if block.start_ea not in visited:
                    find_graph(block, parent, visited, adj_parent, count)
                    print("Disconnected blocks")

        print_graph(adj_parent)

main()
