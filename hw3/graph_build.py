import idautils
import idc
import idaapi
import pickle

"""
visited: keeps track of block visits, using the block start address as the key
count: to have a unique id for each instruction

parent_adj: it the main data structure to store the result
<outer_key, {inner_key:[List]}>

outer_key stores the hex address corresponding to the instruction

inner_key stores the node id(instruction id)

List: stores the parent instruction id, 0th index contains the instruction in assembly

"""


# Logic is mostly similar to DFS
def find_graph(block,block_start,block_end,parent,visited,parent_adj,count):
    visited[block_start]=1
    
    #First parsing current block instructions
    insts = idautils.Heads(block_start,block_end)

    for ins in insts:
        node_id = "n{}".format(count[0])
        parent_adj[hex(ins)]={}
        #node_id = "n{}".format(count)
        parent_adj[hex(ins)][node_id]=[idc.GetDisasm(ins),parent]
        parent=node_id
        count[0] = count[0] + 1
    
    # Now call for all the successive blocks
    for succ_block in block.succs():
            #print("outside",block)
            if succ_block.start_ea not in visited:
                find_graph(succ_block,succ_block.start_ea, succ_block.end_ea,parent,visited,parent_adj,count) # recursive call
            else:
                # gets_added_in_calle_first_ins_as_parent
                insts = idautils.Heads(succ_block.start_ea, succ_block.end_ea)
                for ins in insts:
                    parent_adj[hex(ins)][list(parent_adj[hex(ins)].keys())[0]].append(parent)
                    break
    return


def print_graph(adj_parent):
     ## Printing the parent_adj Dictionary
    # for outer_key in adj_parent.keys():
    #     print(outer_key,"-->",list(adj_parent[outer_key].keys())[0],end=' ')
    #     for inner in adj_parent[outer_key].keys():
    #         print(adj_parent[outer_key][inner])
        #print("\n")
    #print(adj)
    
    ## Making the directed graph from the parent info,
    # graph adjacency list
    
    adj = {}
    for outer_key in adj_parent.keys():
        node_id = list(adj_parent[outer_key].keys())[0]
        node_ins = adj_parent[outer_key][node_id][0]

        node_info_in_final_graph = "({}:{})".format(outer_key,node_ins)
        if node_id not in adj:
            adj[node_id] = [node_info_in_final_graph]
        elif node_id in adj:
            if adj[node_id][0]=="X":
                adj[node_id][0] = node_info_in_final_graph

        for inner in adj_parent[outer_key].keys():
            for i in range(1,len(adj_parent[outer_key][inner])):
                parent_node_id = adj_parent[outer_key][inner][i]
                #print(parent_node_id)
                if parent_node_id not in adj:
                    adj[parent_node_id]=["X",node_id]
                else:
                    adj[parent_node_id].append(node_id)

    # print("Final graph print")
    for outer_key in adj.keys():        
        for i in adj[outer_key][1:]:
            print(outer_key,adj[outer_key][0],"-->",i,adj[i][0])
        #print(adj[outer_key][1:])


def main():
    FUNCTION_NAME = 'first_func_call' #Change this to whatever func you want to look for. May have to change to _start in some cases or code your own logic
    
    print ("Start of the functions")
    cursor = 0
    real_names = []
    addresses = []
    adj_parent = {} # hex_address-->{node_id:[parenets_list]}
    count=[0]
    # with open('saved_dictionary.pkl', 'wb') as f:
    #     pickle.dump(dir, f)
    names = idautils.Names()
    
    # Populate the two above lists with their respective data from the list of tuples returned by idautils.Names()
    for n in names:
        real_names.append(n[1]) # real_names[30] ------> addresses[30]
        addresses.append(n[0])
    
    # search for a 'start' name in the names list and if it is there, set cursor to the address of beginning of it
    for rn in real_names:
        if rn == FUNCTION_NAME:
            cursor = addresses[int(real_names.index(FUNCTION_NAME))]
            break
    
    
    parent="start"
    visited={}
    #count = 1
    if cursor: #if a start was found, assign it to the cursor and then 
        myFunc = idaapi.get_func(cursor)
        f = idaapi.FlowChart(myFunc)
        for block in f:
            if block.start_ea not in visited:
                block_start=block.start_ea
                block_end=block.end_ea
                find_graph(block,block_start,block_end,parent,visited,adj_parent,count)
                print("Disconnected blocks")
     
   
    print_graph(adj_parent)
    


main()


