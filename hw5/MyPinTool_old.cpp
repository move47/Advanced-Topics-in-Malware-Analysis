/*
 * Copyright (C) 2004-2021 Intel Corporation.
 * SPDX-License-Identifier: MIT
 */

#include <stdio.h>
#include "pin.H"
#include <vector>
#include <string>
#include <sstream>
#include <map>
#include <iostream>
#include <fstream>
using namespace std;


FILE* trace;


typedef map< string, string > mp_str_str;
//static vector<string> addr;

//static map<string, string> str_of_ins_at;

static vector<string> as;

static UINT64 flag;


static mp_str_str str_of_ins_at;

ADDRINT unmatched_syscall_ip = 0;

THREADID myThread = INVALID_THREADID;


VOID ThreadStart(THREADID threadid, CONTEXT* ctxt, INT32 flags, VOID* v)
{
    if (myThread == INVALID_THREADID)
    {
        myThread = threadid;
    }
}

VOID BeforeSyscall(ADDRINT ip)
{
    
    if (unmatched_syscall_ip != 0)
    {
        cout<< "AfterSyscall() is not executed after the syscall at" << (unsigned long)unmatched_syscall_ip <<endl;
        fflush(stdout);
        exit(1);
    }
    
    unmatched_syscall_ip = ip;

    //unmatched_syscall_ip = 0;
    flag = 0;

}

VOID AfterSyscall(ADDRINT ip) { unmatched_syscall_ip = 0; flag = 1; }

VOID SyscallEntry(THREADID threadIndex, CONTEXT* ctxt, SYSCALL_STANDARD std, VOID* v)
{
    if (threadIndex == myThread)
    {
        BeforeSyscall(PIN_GetContextReg(ctxt, REG_INST_PTR));
    }
}

VOID SyscallExit(THREADID threadIndex, CONTEXT* ctxt, SYSCALL_STANDARD std, VOID* v)
{
    if (threadIndex == myThread)
    {
        AfterSyscall(PIN_GetContextReg(ctxt, REG_INST_PTR));
    }
}

VOID printIP(VOID* ip, const string* s) {
    std::ostringstream address;
    address << (void const*)ip;
std:string name = address.str();
    //addr.push_back(name);
    //cout << "dis: " << name << endl;
    string s1 = name;
    //cout << "Dis: " << s1 << endl;
    //printf("dis: %s\n", name);
    //str_of_ins_at[s1] = s->c_str();
    //fprintf(trace, "%s --> %s\n", s1, str_of_ins_at[s1]);
    fprintf(trace, "%p --> %s\n", ip, s->c_str());
    //str_of_ins_at[ip] = INS_Disassemble(ins);
}

VOID Instruction(INS ins, VOID* v)
{
    // For O/S's (macOS*) that don't support PIN_AddSyscallEntryFunction(),
    // instrument the system call instruction.

    if (INS_IsSyscall(ins) && INS_IsValidForIpointAfter(ins))
    {
        cout << INS_Disassemble(ins) << endl;
        INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)BeforeSyscall, IARG_INST_PTR, IARG_END);
        INS_InsertCall(ins, IPOINT_AFTER, (AFUNPTR)AfterSyscall, IARG_INST_PTR, IARG_END);
    }

    else if (flag==1)
    {
        string instrString = INS_Disassemble(ins);
        INS_InsertCall(ins, IPOINT_BEFORE,
            (AFUNPTR)printIP,
            IARG_INST_PTR,
            IARG_PTR, new string(instrString),
            IARG_END);
    }
}

static VOID OnContextChange(THREADID threadIndex, CONTEXT_CHANGE_REASON reason, const CONTEXT* ctxtFrom, CONTEXT* ctxtTo,
    INT32 info, VOID* v)
{
    // We may jump to UPC/signal while in system call (i.e. before it is return)
    // The code of this UPC may in its turn call another system call which will
    // see unmatched_syscall_ip != 0.
    unmatched_syscall_ip = 0;
}


// This function is called when the application exits
VOID Fini(INT32 code, VOID* v)
{
    /*
    for (int i = 0; i < addr.size(); i++)
    {
        fprintf(trace, "%s", addr[i]);
        //string name = "temp";
        //fprintf(trace, "%s",name);

        //printf("adding: %s",addr[i]);
    }
    string name = "temp";
    fprintf(trace, "name\n");
    //fprintf(trace, "#eof\n");*/

    /*
    char lang[5][20] = { "C","C++","Java","Python","PHP" };
    fprintf(trace, "Top 5 programming language\n");
    for (int i = 0; i < 5; i++)
        fprintf(trace, "%d. %s\n", i + 1, lang[i]);
    */


    
    //vector<string>::iterator it = as.begin();
    /*
    for (mp_str_str::iterator bi = str_of_ins_at.begin(); bi != str_of_ins_at.end(); bi++)
    {
        //bi->second = UINT64(bi->second * factor);
        fprintf(trace, "%s --> %s\n", bi->first, bi->second);
    }
    */
    fprintf(trace, "Hi\n");
    /*
    map<string, string>::iterator it = str_of_ins_at.begin();
    while (it != str_of_ins_at.end())
    {
        fprintf(trace, "%s --> %s\n", it->first,it->second);
        it++;
    }
    
    */

    //for (int i = 0; i < 2; i++)
      //  {
        //    fprintf(trace, "%s\n", as[i]);

        //}
    
    fprintf(trace, "#eof\n");
    fclose(trace);
}

/* ===================================================================== */
/* Print Help Message                                                    */
/* ===================================================================== */

INT32 Usage()
{
    PIN_ERROR("This Pintool prints the IPs of every instruction executed\n" + KNOB_BASE::StringKnobSummary() + "\n");
    return -1;
}

/* ===================================================================== */
/* Main                                                                  */
/* ===================================================================== */

int main(int argc, char* argv[])
{
    trace = fopen("itrace_test_2.out", "w");
    PIN_InitSymbols();
    /*
    fprintf(trace, "name\n");
    //fprintf(trace, "#eof\n");
    char lang[5][20] = { "C","C++","Java","Python","PHP" };
    fprintf(trace, "Top 5 programming language\n");
    for (int i = 0; i < 5; i++)
        fprintf(trace, "%d. %s\n", i + 1, lang[i]);
    */
    flag = 1;
    // Initialize pin
    if (PIN_Init(argc, argv)) return Usage();


    //IMG_AddInstrumentFunction(Image, 0);
    // Register Instruction to be called to instrument instructions
    INS_AddInstrumentFunction(Instruction, 0);


    PIN_AddSyscallEntryFunction(SyscallEntry, NULL);
    PIN_AddSyscallExitFunction(SyscallExit, NULL);

    PIN_AddContextChangeFunction(OnContextChange, NULL);

    //Image
    //IMG_AddInstrumentFunction(ImageLoad, 0);

    // Register Fini to be called when the application exits
    PIN_AddFiniFunction(Fini, 0);

    // Start the program, never returns
    PIN_StartProgram();

    return 0;
}
