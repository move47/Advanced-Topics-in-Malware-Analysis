
/* Pin tool for making a DOT file for the executed instrucitons*/

/**
 * references:
 * https://stackoverflow.com/questions/54499458/printing-program-and-function-name-of-each-instruction-with-pin-tool
 * https://sonysame.tistory.com/371
 * https://people.cs.vt.edu/~gback/cs6304.spring07/pin2/Doc/Pin/html/group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d0faf9829bd4f46cc1873c943978b21d7
*/

#include "pin.H"
#include <stdlib.h>
#include <stdio.h>
#include <vector>
#include <map>
#include <unordered_map>
#include <fstream>
#include <iostream>
#include <sstream>
#include <iosfwd>

using std::cerr;
using std::endl;
using std::flush;
using std::map;
using std::pair;
using std::setw;
using std::string;
using std::vector;
//using std::to_string;
//using unordered_map;
using std::ios_base;

typedef pair< string, UINT64 > PAIR;
typedef map <PAIR, UINT64> Mymap;
typedef vector <PAIR> INSTSvec;


KNOB<string> KnobOutputFile(KNOB_MODE_WRITEONCE, "pintool", "o", "Output.dot", "specify file name");

std::ofstream TraceFile;

static Mymap AddrMap;
static INSTSvec INST_VEC;

// for every instruction print the entry in diagraph
// we explored few options to store the data in memory and write to file only in fin,
// none of them seem to work correctly
// since writing to file for every instruction wasn't terribly slow for greencat, so we decided to keep it
VOID print(VOID* ip, VOID* ipn, ADDRINT tid, string* s) {
	std::ostringstream address;
	address << (void const*)ip;
std:string ins_add = address.str();
	UINT64 count = 0;
	UINT64 i = 2;
	// detect leading zeros
	for (; i < ins_add.length(); i++)
	{
		if (ins_add[i] == '0')
		{
			count = count + 1;
		}
		else
		{
			break;
		}
	}

	string s1 = "";
	for (UINT64 i = 0; i < count; i++)
	{
		s1 = s1 + "0";
	}

	UINT64 next_ins_addr = tid;
	PAIR to_search = std::make_pair(ins_add, next_ins_addr);

	//insert only if the pair wasn't seen earlier
	if (AddrMap.find(to_search) == AddrMap.end())
	{
		long pos = TraceFile.tellp();
		TraceFile.seekp(-1, ios_base::end);
		TraceFile.write("", 0);
		TraceFile << "\"" << ins_add << "\"  " << "->" << "  " << "\"" << "0x" << s1 << std::hex << tid << "\"" << endl;
		TraceFile.write("\n", 1);

		TraceFile.seekp(-1, ios_base::end);

		pos = TraceFile.tellp();
		TraceFile.seekp(-1, ios_base::end);
		TraceFile.write("}", 1);
		// update map
		AddrMap[to_search] = 1;
	}
}

VOID ImageLoad(IMG img, VOID* v)
{
	// check if image loaded is main executable
	if (IMG_IsMainExecutable(img)) {
		TraceFile << "digraph G {" << endl;
		// go through all the sections
		for (SEC sec = IMG_SecHead(img); SEC_Valid(sec); sec = SEC_Next(sec))
		{
			// filter executable section
			if (SEC_IsExecutable(sec))
			{
				// go through every routine (function)
				for (RTN rtn = SEC_RtnHead(sec); RTN_Valid(rtn); rtn = RTN_Next(rtn)) {
					RTN_Open(rtn);
					// go through every function
					for (INS ins = RTN_InsHead(rtn); INS_Valid(ins); ins = INS_Next(ins)) {
						if (INS_Valid(INS_Next(ins)))
						{
							// call print function on every instruction found till this point
							INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)print, IARG_INST_PTR, IARG_PTR, INS_Next(ins), IARG_ADDRINT, INS_Address(INS_Next(ins)), IARG_PTR, new string(INS_Disassemble(ins)), IARG_END);
						}
					}
					RTN_Close(rtn);
				}
			}
		}
	}
}

// This function is called when the application exits
// It closes the output file.
VOID Fini(INT32 code, VOID* v)
{
	if (TraceFile.is_open()) {
		TraceFile.close();
	}
}

/* ===================================================================== */
/* Print Help Message                                                    */
/* ===================================================================== */

INT32 Usage()
{
	PIN_ERROR("This tool prints a log of image load and unload events\n"
		+ KNOB_BASE::StringKnobSummary() + "\n");
	return -1;
}

/* ===================================================================== */
/* Main                                                                  */
/* ===================================================================== */

int main(int argc, char* argv[])
{
	// Initialize symbol processing
	PIN_InitSymbols();

	// Initialize pin
	if (PIN_Init(argc, argv)) return Usage();

	TraceFile.open(KnobOutputFile.Value().c_str());

	// Register ImageLoad to be called when an image is loaded
	IMG_AddInstrumentFunction(ImageLoad, 0);

	// Register Fini to be called when the application exits
	PIN_AddFiniFunction(Fini, 0);

	// Start the program, never returns
	PIN_StartProgram();

	return 0;
}