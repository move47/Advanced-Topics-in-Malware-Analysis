
/* Pin tool for making a DOT file for the executed instrucitons*/

#include "pin.H"
#include <stdlib.h>
#include <stdio.h>
#include <vector>
#include <map>
#include <unordered_map>
#include <fstream>
#include <iostream>
#include <sstream>
#include <iosfwd>

using std::cerr;
using std::endl;
using std::flush;
using std::map;
using std::pair;
using std::setw;
using std::string;
using std::vector;
//using std::to_string;
//using unordered_map;
using std::ios_base;

typedef pair< string, UINT64 > PAIR;
typedef map <PAIR, UINT64> Mymap;
typedef vector <PAIR> INSTSvec;


KNOB<string> KnobOutputFile(KNOB_MODE_WRITEONCE, "pintool","o", "imageO.out", "specify file name");

std::ofstream TraceFile;

static Mymap AddrMap;
static INSTSvec INST_VEC;

VOID print(VOID* ip, VOID* ipn, ADDRINT tid, string* s) {
	
	std::ostringstream address;
	address << (void const*)ip;
	std:string ins_add = address.str();
	

	UINT64 count = 0;
	UINT64 i = 2;
	for(;i<ins_add.length();i++)
	{
		//std::cout << i << std::endl;
		if (ins_add[i] == '0')
		{
			count = count + 1;
		}
		else
		{
			break;
		}
	}

	string s1 = "";
	for (UINT64 i = 0; i<count; i++)
	{
		s1 = s1 + "0";
	}

	//string next_ins_add = s1 + to_string(tid);
	 



	//addr.push_back(name);
	//cout << "dis: " << name << endl;
	//string s1 = name;
	//InsMap[s1].first = *s;
	UINT64 next_ins_addr = tid;
	//std::cout << tid << std::endl;
	PAIR to_search = std::make_pair(ins_add, next_ins_addr);
	if (AddrMap.find(to_search) == AddrMap.end())
	{
		//TraceFile << std::hex << ip << "	"<< std::hex << ipn << "	" << "0x"<< std::hex << tid << "  " << *s << endl;
		//TraceFile << ins_add << "	" << std::hex << ipn << "	" << next_ins_addr << "  " << *s << endl;
		//TraceFile << ins_add << "	" << "->" << "  " << "0x"<< s1 << next_ins_addr << "  " << *s << endl;
		long pos = TraceFile.tellp();
		TraceFile.seekp(-1, ios_base::end);
		TraceFile.write("", 0);
		TraceFile <<"\""<< ins_add << "\"  " << "->" << "  " << "\""<<"0x" << s1 << std::hex << tid << "\""<<endl;
		TraceFile.write("\n",1);
		//TraceFile.write("This is an apple", 16);
		TraceFile.seekp(-1, ios_base::end);
		
		/*if ()
		{
			TraceFile.put("}");
		}
		*/
		pos = TraceFile.tellp();
		TraceFile.seekp(-1, ios_base::end);
		TraceFile.write("}", 1);


		AddrMap[to_search] = 1;
	}
	//INST_VEC.push_back(std::make_pair(s1,*s));
}

VOID ImageLoad(IMG img, VOID* v)
{
	if (IMG_IsMainExecutable(img)) {
		//TraceFile << IMG_Name(img) << endl;
		TraceFile << "digraph G {" << endl;
		for (SEC sec = IMG_SecHead(img); SEC_Valid(sec); sec = SEC_Next(sec))
		{
			if (SEC_IsExecutable(sec))
			{
				//TraceFile << "Address: 0x" << std::hex << SEC_Address(sec) << " SEC_name " << SEC_Name(sec) << " is executable" << endl;
				for (RTN rtn = SEC_RtnHead(sec); RTN_Valid(rtn); rtn = RTN_Next(rtn)) {
					RTN_Open(rtn);
					for (INS ins = RTN_InsHead(rtn); INS_Valid(ins); ins = INS_Next(ins)) {
						if (INS_Valid(INS_Next(ins)))
						{
							//IARG_
							INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)print, IARG_INST_PTR, IARG_PTR, INS_Next(ins), IARG_ADDRINT, INS_Address(INS_Next(ins)), IARG_PTR, new string(INS_Disassemble(ins)), IARG_END);
						}
						
					}
					RTN_Close(rtn);
				}
			}
			else { 
				//TraceFile << "Address: 0x" << std::hex << SEC_Address(sec) << " SEC_name " << SEC_Name(sec) << endl; 
			}
		}
	}
}

// This function is called when the application exits
// It closes the output file.
VOID Fini(INT32 code, VOID* v)
{
	if (TraceFile.is_open()) { 
		
		/*
		for (INSTSvec::iterator bi = INST_VEC.begin(); bi != INST_VEC.end()-1; bi++)
		{
			InsMap[*bi] = 1;
			std::cout << " " << bi->first << "  " << bi->second << endl;
		}
		*/
		//TraceFile << "}" << endl;
		TraceFile.close(); 
	
	}
}

/* ===================================================================== */
/* Print Help Message                                                    */
/* ===================================================================== */

INT32 Usage()
{
	PIN_ERROR("This tool prints a log of image load and unload events\n"
		+ KNOB_BASE::StringKnobSummary() + "\n");
	return -1;
}

/* ===================================================================== */
/* Main                                                                  */
/* ===================================================================== */

int main(int argc, char* argv[])
{
	// Initialize symbol processing
	PIN_InitSymbols();

	// Initialize pin
	if (PIN_Init(argc, argv)) return Usage();

	TraceFile.open(KnobOutputFile.Value().c_str());

	// Register ImageLoad to be called when an image is loaded
	IMG_AddInstrumentFunction(ImageLoad, 0);

	// Register Fini to be called when the application exits
	PIN_AddFiniFunction(Fini, 0);

	// Start the program, never returns
	PIN_StartProgram();

	return 0;
}