Goal: Dynamic Control Dependence

Instructions:
(1) Extend the pintool designed for Lab #5 to trace the control dependence of every instruction that is executed. To do so, your pintool will need to implement one of the dynamic control dependence algorithms discussed in class. It does not matter which algorithm you choose to implement, but I would recommend the "Regions" approach. Do the execution tracing entirely in memory! Your pintool should only write to an output file in the ThreadFini function.

To determine control dependence, you will need to identify the immediate `post-dominators` of many instructions. You can either obtain this statically (with an IDA Pro plugin that outputs static immediate post dominators as a dictionary) or dynamically (with the control flow trace that your pintool generated for Lab #5).  Again, you can choose either method to implement. Moreover, it is fine if solution requires executing the dynamic analysis multiple times.

(2) After the process that your pintool is tracing exits (i.e., in your pintool's ThreadFini function), generate a DOT directed graph file representing the control dependence of all the observed instructions. Each node in your DOT directed graph file should be the address of an instruction that was executed (only ONE node per instruction address). The edges in your DOT directed graph file should go from each executed instruction to the instructions that it is control dependent on.

(3) Use your pintool and explore all the different control flow paths that each of the greencat command and control (C&C) commands exercise. Refer back to [Lab #2](../Lab%20%232/)recover the C&C commands that greencat accepts from its C&C server. Send each command to greencat (one time is enough; order does not matter) and generate one DOT file.

Dependencies

pip install networkx

pip install nxpydot
