	.file	"hello.c"
	.intel_syntax noprefix
	.text  							;tells the assembler to switch to the text segement where the code actually goes
	.section	.rodata
.LC0:
	.string	"Hello %s\n"
	.text
	.globl	main
	.type	main, @function
main:
	endbr64        							; NOP. Marks that it is a valid jump target addresses for indirect calls and jumps in the program.
	push	rbp    							; Pushes current base pointer (of the calling function) onto the stack, so it can be restored later
	mov	rbp, rsp 							; Value of base pointer is set to the address of the stack pointer, so that the base pointer will point to top of the stack
	sub	rsp, 16        					    ; Grow the stack by 16 bytes to reserve space for local variables
	mov	DWORD PTR -4[rbp], edi 				; Copies the 4 Bytes value of edi holding number of arguments(argc) in address rbp-4
	mov	QWORD PTR -16[rbp], rsi			    ; Copies the value of pointer to argv[0] into the address rbp-16 i.e. two locations below the current rbp pointer
	cmp	DWORD PTR -4[rbp], 2                ; Compares the value of argc stored at rbp-4 with #2
	jne	.L2                  			    ; If argc is not equal to 2, then jump to .L2 label. Otherwise continue executing the next instruction.
	mov	rax, QWORD PTR -16[rbp] 			; Copies the value of address to argv[0] into rax. The source can also be used as rsi.  
	add	rax, 8                  			; rax <- rax+8.. necessarily to move the argv pointer to 1st index. Addition is 8 as it is char array. 
	mov	rax, QWORD PTR [rax]    			; copies the exact value lying at argv[1] into the rax. 
	mov	rsi, rax							; copies the value of rax into rsi. Earlier rsi contained the argv[0] address, now it will have argv[1] value. 
	lea	rax, .LC0[rip]						; Load the effective address of .LC0+rip (Instrution pointer) into rax. It is an example of relative addressing scheme. 
	mov	rdi, rax							; copies the value of rax into rdi. Make it as destination index.
	mov	eax, 0                  			; Fuction epilogue. Making accumulator value 0. (zero extended operation)
	call	printf@PLT						; calling the external symbol (printf funtion) that exists in shared library. PLT helps in locating the printf code in memory. It is an example of Dynamic linking.
.L2:
	mov	eax, 0                              ; Makes the value of eax register as 0; zero-extended instruction
	leave									; set rsp to rbp, then pop rbp. rbp now contains the calling procedure's frame pointer.
	ret										; returns program control to the calling procedure
	.size	main, .-main
	.ident	"GCC: (Ubuntu 11.2.0-19ubuntu1) 11.2.0"
	.section	.note.GNU-stack,"",@progbits
	.section	.note.gnu.property,"a"
	.align 8
	.long	1f - 0f
	.long	4f - 1f
	.long	5
0:
	.string	"GNU"
1:
	.align 8
	.long	0xc0000002
	.long	3f - 2f
2:
	.long	0x3
3:
	.align 8
4:
