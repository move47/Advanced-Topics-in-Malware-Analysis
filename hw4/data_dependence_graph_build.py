from cProfile import label
from re import I
import idautils
import idc
import idaapi
import pickle
from typing import Dict, List, Tuple

def check_call(ins):
    return idaapi.is_call_insn(ins)

def check_branches(ins):
    # reference: https://github.com/lifting-bits/mcsema-legacy/blob/master/tools/mcsema_disass/ida/get_cfg.py
    COND_BRANCHES = [\
    idaapi.NN_ja,\
    idaapi.NN_jae,\
    idaapi.NN_jb,\
    idaapi.NN_jbe,\
    idaapi.NN_jc,\
    idaapi.NN_jcxz,\
    idaapi.NN_je,\
    idaapi.NN_jecxz,\
    idaapi.NN_jg,\
    idaapi.NN_jge,\
    idaapi.NN_jl,\
    idaapi.NN_jle,\
    idaapi.NN_jna,\
    idaapi.NN_jnae,\
    idaapi.NN_jnb,\
    idaapi.NN_jnbe,\
    idaapi.NN_jnc,\
    idaapi.NN_jne,\
    idaapi.NN_jng,\
    idaapi.NN_jnge,\
    idaapi.NN_jnl,\
    idaapi.NN_jnle,\
    idaapi.NN_jno,\
    idaapi.NN_jnp,\
    idaapi.NN_jns,\
    idaapi.NN_jnz,\
    idaapi.NN_jo,\
    idaapi.NN_jp,\
    idaapi.NN_jpe,\
    idaapi.NN_jpo,\
    idaapi.NN_jrcxz,\
    idaapi.NN_js,\
    idaapi.NN_jz,]

    UCOND_BRANCHES = [\
        idaapi.NN_jmp,\
        idaapi.NN_jmpfi,\
        idaapi.NN_jmpni,\
        idaapi.NN_jmpshort]

    op = idautils.DecodeInstruction(ins).itype
    return op in COND_BRANCHES or op in UCOND_BRANCHES

def check_push(ins):
    insn_t = idautils.DecodeInstruction(ins)
    return insn_t.itype == idaapi.NN_push


def check_pop(ins):
    op = idautils.DecodeInstruction(ins).itype
    return op == idaapi.NN_pop

def check_ret(ins):
    op = idautils.DecodeInstruction(ins).itype
    return op == idaapi.NN_retn

def check_eflag_use(ins):
    if check_branches(ins):
        return True
    # TODO: add to this list
    FLAG_USE_CMDS = [
    ]
    op = idautils.DecodeInstruction(ins).itype
    return op in FLAG_USE_CMDS

def check_eflag_def(ins):
    # TODO: add to this list
    FLAG_DEF_CMDS = [
        idaapi.NN_add,
        idaapi.NN_sub,
        idaapi.NN_mul,
        idaapi.NN_div,
        idaapi.NN_xor,
        idaapi.NN_or,
        idaapi.NN_and,
        idaapi.NN_not,
        idaapi.NN_cmp,
        idaapi.NN_inc,
        idaapi.NN_dec,
        idaapi.NN_test,
    ]
    op = idautils.DecodeInstruction(ins).itype
    return op in FLAG_DEF_CMDS

class inst_info():
    def __init__(self, D_list, U_list, inst):
        self.D_list = D_list
        self.U_list = U_list
        self.inst = inst
        self.parent_list = list()
        self.data_dependence_set = set()

def mem_split (ins,op):
        is_mem = op.type in (idaapi.o_phrase, idaapi.o_displ) #idaapi.o_mem can be added to handle direct memory address
        result = []
        if is_mem:
            x = idc.print_operand(ins, op.n)
            y_1,y_2 = x.split('[')
            y_3,y_4 = y_2.split(']')
            y_4 = y_3.split('+')
            #y[0] = y[0][1:]
            # y_4[-1] = y_4[-1][:-1]
            for i in y_4:
                if i[-1]!='h':
                    #print(i)
                    result.append(i)
            return result

def get_Defined_Used(ins):

    """
    for every operand in the instruction check if write or read flag is set.
    mark operand as used if read is set, mark it as defined if write flag is set
    reference: https://reverseengineering.stackexchange.com/questions/12053/ida-generic-approach-to-determine-if-an-instruction-reads-from-or-writes-to-m
    """

    D = list()
    U = list()

    OPND_WRITE_FLAGS = {
        0: idaapi.CF_CHG1,
        1: idaapi.CF_CHG2,
        2: idaapi.CF_CHG3,
        3: idaapi.CF_CHG4,
        4: idaapi.CF_CHG5,
        5: idaapi.CF_CHG6,
    }

    OPND_READ_FLAGS = {
        0: idaapi.CF_USE1,
        1: idaapi.CF_USE2,
        2: idaapi.CF_USE3,
        3: idaapi.CF_USE4,
        4: idaapi.CF_USE5,
        5: idaapi.CF_USE6,
    }

    insn = idautils.DecodeInstruction(ins)
    feature = insn.get_canon_feature()

    for op in insn.ops:
        if op.type == idaapi.o_void:
            break

        if idc.get_operand_type(ins,op.n)==5:
            continue

        # There are 3 types of memory references in IDA. We want only 2.
        is_write = feature & OPND_WRITE_FLAGS[op.n]
        is_read = feature & OPND_READ_FLAGS[op.n]

        if(is_write):
            D.append(idc.print_operand(ins, op.n))
            is_mem = op.type in (idaapi.o_phrase, idaapi.o_displ) #idaapi.o_mem can be added to handle direct memory address
            if is_mem:
                split_result = mem_split(ins,op)
                split_result = mem_split(ins,op)
                for i in split_result:
                    U.append(i)

        if(is_read):
            is_mem = op.type in (idaapi.o_phrase, idaapi.o_displ) #idaapi.o_mem can be added to handle direct memory address
            if is_mem:
                split_result = mem_split(ins,op)
                for i in split_result:
                    U.append(i)
            else:
                U.append(idc.print_operand(ins, op.n))

    if check_push(ins):
        D += ['esp', '[esp]']
        U += ['esp']

    if check_pop(ins):
        D += ["esp"]
        U += ["esp", "[esp]"]

    if check_call(ins):
        D += ["eax", "esp"]
        U += ["esp"]

    if check_ret(ins):
        pass
        #nothing doing, ref does nothing

    if check_eflag_def(ins):
        D += ['eFlags']

    if check_eflag_use(ins):
        U += ['eFlags']

    return D,U

def find_data_dependence(node_id, parent_adj: Dict[str, inst_info], operand, op_visited):
    '''
    From current node, traverse backward (scan all parents) until you find def of the operand.
    If there are no defs assume it comes from start
    '''
    dependence_set = set()
    if node_id in op_visited:
        return dependence_set

    op_visited.add(node_id)

    for node in parent_adj[node_id].parent_list:
        if node == "start":
            dependence_set.add("start")
            continue

        if operand in parent_adj[node].D_list:
            dependence_set.add(node)
        else:
            dependence_set = dependence_set.union(find_data_dependence(node, parent_adj, operand, op_visited))

    return dependence_set

# Logic is mostly similar to DFS
def find_graph(block, parent, visited, parent_adj: Dict[str, inst_info], count, output_file, addr_node_id_map : Dict[str,str]):
    visited[block.start_ea]=1

    #First parsing current block instructions
    insts = idautils.Heads(block.start_ea, block.end_ea)

    for ins in insts:
        node_id = "n{}".format(count[0])
        addr_node_id_map[hex(ins)] = node_id
        parent_adj[node_id] = {}
        D_list, U_list = get_Defined_Used(ins)
        parent_adj[node_id] = inst_info(D_list, U_list, idc.GetDisasm(ins))
        parent_adj[node_id].parent_list.append(parent)
        parent = node_id
        count[0] = count[0] + 1

        for operand in U_list:
            op_visited = set()
            dependence_set = find_data_dependence(node_id, parent_adj, operand, op_visited)
            parent_adj[node_id].data_dependence_set = parent_adj[node_id].data_dependence_set.union(dependence_set)

        print("{0} [label=\"{1}; D: {2}; U: {3} DD: {4}\"]".format(node_id, hex(ins), D_list, U_list, parent_adj[node_id].data_dependence_set))
        output_file.write("{0} [label=\"{1}; D: {2}; U: {3} DD: {4}\"]".format(node_id, hex(ins), D_list, U_list, parent_adj[node_id].data_dependence_set))

    # Now call for all the successive blocks
    for succ_block in block.succs():
        #print("outside",block)
        if succ_block.start_ea not in visited:
            find_graph(succ_block, parent, visited, parent_adj, count, output_file, addr_node_id_map) # recursive call
        else:
            # gets_added_in_calle_first_ins_as_parent
            ins = succ_block.start_ea
            n_id = addr_node_id_map[hex(ins)]
            parent_adj[n_id].parent_list.append(parent)
    return

def print_graph(adj_parent: Dict[str, inst_info],output_file):
    output_file.write("\n\n\n")
    for node_id in adj_parent:
        curr_node = node_id

        for dependent in adj_parent[node_id].data_dependence_set:
            print("{0} -> {1}".format(curr_node, dependent))
            output_file.write("{0} -> {1}\n".format(curr_node, dependent))
    output_file.write("\n}\n")

def main():
    print ("Start of the functions")
    for curr_function in idautils.Functions():
        #output_dir = "DOT_FILES"
        FUNCTION_NAME = idc.get_func_name(curr_function)
        # FUNCTION_NAME = "start"
        dot_file_name = "{}.dot".format(FUNCTION_NAME)
        #with open(dot_file_name,'w') as output_file
        output_file = open(dot_file_name,'w')
        output_file.write('digraph G {\n')
        print("\nCURRENT FUNCTION IS {0}".format(FUNCTION_NAME))
        for _ in range(0,2):
            print("**********************************************")
        #FUNCTION_NAME = 'start' #Change this to whatever func you want to look for. May have to change to _start in some cases or code your own logic

        cursor = 0
        real_names = []
        addresses = []

        adj_parent : Dict[str, inst_info]= {} # hex_address-->{hex addr: inst_info}
        count = [0]
        addr_node_id_map : Dict[str,str] = {}
        names = idautils.Names()

        # Populate the two above lists with their respective data from the list of tuples returned by idautils.Names()
        for n in names:
            real_names.append(n[1]) # real_names[30] ------> addresses[30]
            addresses.append(n[0])

        # search for a 'start' name in the names list and if it is there, set cursor to the address of beginning of it
        for rn in real_names:
            if rn == FUNCTION_NAME:
                cursor = addresses[int(real_names.index(FUNCTION_NAME))]
                break

        parent="start"
        visited={}

        if cursor: #if a start was found, assign it to the cursor and then
            myFunc = idaapi.get_func(cursor)
            f = idaapi.FlowChart(myFunc)
            for block in f:
                if block.start_ea not in visited:
                    find_graph(block, parent, visited, adj_parent, count,output_file, addr_node_id_map)
                    print("Disconnected blocks")

            print_graph(adj_parent,output_file)
main()