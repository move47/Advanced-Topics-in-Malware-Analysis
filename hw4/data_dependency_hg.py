from cProfile import label
from re import I
import idautils
import idc
import idaapi
import pickle
from typing import Dict, List, Tuple
from collections import deque
import re

def check_call(ins):
    return idaapi.is_call_insn(ins)

def check_branches(ins):
    # reference: https://github.com/lifting-bits/mcsema-legacy/blob/master/tools/mcsema_disass/ida/get_cfg.py
    COND_BRANCHES = [\
    idaapi.NN_ja,\
    idaapi.NN_jae,\
    idaapi.NN_jb,\
    idaapi.NN_jbe,\
    idaapi.NN_jc,\
    idaapi.NN_jcxz,\
    idaapi.NN_je,\
    idaapi.NN_jecxz,\
    idaapi.NN_jg,\
    idaapi.NN_jge,\
    idaapi.NN_jl,\
    idaapi.NN_jle,\
    idaapi.NN_jna,\
    idaapi.NN_jnae,\
    idaapi.NN_jnb,\
    idaapi.NN_jnbe,\
    idaapi.NN_jnc,\
    idaapi.NN_jne,\
    idaapi.NN_jng,\
    idaapi.NN_jnge,\
    idaapi.NN_jnl,\
    idaapi.NN_jnle,\
    idaapi.NN_jno,\
    idaapi.NN_jnp,\
    idaapi.NN_jns,\
    idaapi.NN_jnz,\
    idaapi.NN_jo,\
    idaapi.NN_jp,\
    idaapi.NN_jpe,\
    idaapi.NN_jpo,\
    idaapi.NN_jrcxz,\
    idaapi.NN_js,\
    idaapi.NN_jz,]

    UCOND_BRANCHES = [\
        idaapi.NN_jmp,\
        idaapi.NN_jmpfi,\
        idaapi.NN_jmpni,\
        idaapi.NN_jmpshort]

    op = idautils.DecodeInstruction(ins).itype
    return op in COND_BRANCHES or op in UCOND_BRANCHES

def check_push(ins):
    insn_t = idautils.DecodeInstruction(ins)
    return insn_t.itype == idaapi.NN_push

def check_pop(ins):
    op = idautils.DecodeInstruction(ins).itype
    return op == idaapi.NN_pop

def check_ret(ins):
    op = idautils.DecodeInstruction(ins).itype
    return op == idaapi.NN_retn

def check_eflag_use(ins):
    if check_branches(ins):
        return True
    # TODO: add to this list
    FLAG_USE_CMDS = [
    ]
    op = idautils.DecodeInstruction(ins).itype
    return op in FLAG_USE_CMDS

def check_eflag_def(ins):
    # TODO: add to this list
    FLAG_DEF_CMDS = [
        idaapi.NN_add,
        idaapi.NN_sub,
        idaapi.NN_mul,
        idaapi.NN_div,
        idaapi.NN_xor,
        idaapi.NN_or,
        idaapi.NN_and,
        idaapi.NN_not,
        idaapi.NN_cmp,
        idaapi.NN_inc,
        idaapi.NN_dec,
        idaapi.NN_test,
    ]
    op = idautils.DecodeInstruction(ins).itype
    return op in FLAG_DEF_CMDS

class inst_info():
    def __init__(self, D_list, U_list, inst):
        self.D_list = D_list
        self.U_list = U_list
        self.inst = inst
        self.parent_list = list()
        self.data_dependence_set = set()

def mem_split (ins,op):
        is_mem = op.type in (idaapi.o_phrase, idaapi.o_displ) #idaapi.o_mem can be added to handle direct memory address
        result = []
        pattern = r'[rea][a-dsbi]*[xlhip][\+\*]'
        #print(re.findall(pattern,s))
        if is_mem:
            """
            x = idc.print_operand(ins, op.n)
            y_1,y_2 = x.split('[')
            y_3,y_4 = y_2.split(']')
            y_4 = y_3.split('+')
            #y[0] = y[0][1:]
            # y_4[-1] = y_4[-1][:-1]
            for i in y_4:
                if i[-1]!='h':
                    #print(i)
                    result.append(i)
                    
            """
            operand = idc.print_operand(ins, op.n)
            list = re.findall(pattern,operand)
            if len(list)==0:
                pattern = r'\[[rea][a-dsbi]*[xlhip]\]'
                list = re.findall(pattern,operand)
                for i in list:
                    result.append(i[1:-1])
            else:
                for i in list:
                    result.append(i[:-1])
            return result

def get_Defined_Used(ins):

    """
    for every operand in the instruction check if write or read flag is set.
    mark operand as used if read is set, mark it as defined if write flag is set
    reference: https://reverseengineering.stackexchange.com/questions/12053/ida-generic-approach-to-determine-if-an-instruction-reads-from-or-writes-to-m
    """

    D = list()
    U = list()

    OPND_WRITE_FLAGS = {
        0: idaapi.CF_CHG1,
        1: idaapi.CF_CHG2,
        2: idaapi.CF_CHG3,
        3: idaapi.CF_CHG4,
        4: idaapi.CF_CHG5,
        5: idaapi.CF_CHG6,
    }

    OPND_READ_FLAGS = {
        0: idaapi.CF_USE1,
        1: idaapi.CF_USE2,
        2: idaapi.CF_USE3,
        3: idaapi.CF_USE4,
        4: idaapi.CF_USE5,
        5: idaapi.CF_USE6,
    }

    insn = idautils.DecodeInstruction(ins)
    feature = insn.get_canon_feature()

    for op in insn.ops:
        if op.type == idaapi.o_void:
            break

        if idc.get_operand_type(ins,op.n)==5:
            continue
        if op.type ==idaapi.o_mem:
            print("Direct mem: ", idc.GetDisasm(ins))

        # There are 3 types of memory references in IDA. We want only 2.
        is_write = feature & OPND_WRITE_FLAGS[op.n]
        is_read = feature & OPND_READ_FLAGS[op.n]

        if(is_write):
            D.append(idc.print_operand(ins, op.n))
            is_mem = op.type in (idaapi.o_phrase, idaapi.o_displ) #idaapi.o_mem can be added to handle direct memory address
            if is_mem:
                split_result = mem_split(ins,op)
                split_result = mem_split(ins,op)
                for i in split_result:
                    U.append(i)
            if op.type ==idaapi.o_mem:
                U.append(idc.print_operand(ins, op.n))
                
                

        if(is_read):
            is_mem = op.type in (idaapi.o_phrase, idaapi.o_displ) #idaapi.o_mem can be added to handle direct memory address
            if is_mem:
                split_result = mem_split(ins,op)
                for i in split_result:
                    U.append(i)
            else:
                U.append(idc.print_operand(ins, op.n))

    if check_push(ins):
        D += ['esp', '[esp]']
        U += ['esp']

    if check_pop(ins):
        D += ["esp"]
        U += ["esp", "[esp]"]

    if check_call(ins):
        D += ["eax", "esp"]
        U += ["esp"]

    if check_ret(ins):
        pass
        #nothing doing, ref does nothing

    if check_eflag_def(ins):
        D += ['eFlags']

    if check_eflag_use(ins):
        U += ['eFlags']

    return D,U

def find_data_dependence(node_addr, parent_adj: Dict[str, inst_info], operand, op_visited):
    '''
    From current node, traverse backward (scan all parents) until you find def of the operand.
    If there are no defs assume it comes from start
    '''
    dependence_set = set()
    if node_addr in op_visited:
        return dependence_set

    op_visited.add(node_addr)

    for node in parent_adj[node_addr].parent_list:
        if node == "START":
            dependence_set.add("START")
            continue

        if operand in parent_adj[node].D_list:
            dependence_set.add(node)
        else:
            dependence_set = dependence_set.union(find_data_dependence(node, parent_adj, operand, op_visited))

    return dependence_set

def get_stack_dependence(ins, node_addr, shadow_stack):

    d_set = set()
    if check_push(ins):
        shadow_stack.append(node_addr)
        return d_set

    if check_pop(ins):
        d_set.add(shadow_stack[-1])
        shadow_stack.pop()
        return d_set

    insn = idautils.DecodeInstruction(ins)

    if idc.print_operand(ins, 0) == "esp":
        print("esp op found")
        if insn.itype == idaapi.NN_add:
            val = int(idc.print_operand(ins, 1)[:-1],16)
            for _ in range (val):
                shadow_stack.pop()
        elif insn.itype == idaapi.NN_sub:
            val = int(idc.print_operand(ins, 1)[:-1],16)
            for _ in range(val):
                shadow_stack.append("START") # TODO: track local allocations through ebp (should we?)
    return d_set

# Logic is mostly similar to DFS
def find_graph(block, parent, visited, parent_adj: Dict[str, inst_info], count, output_file, addr_node_id_map : Dict[str,str], shadow_stack):
    visited[block.start_ea]=1

    #First parsing current block instructions
    insts = idautils.Heads(block.start_ea, block.end_ea)

    for ins in insts:
        node_id = "n{}".format(count[0])
        addr_node_id_map[hex(ins)] = node_id
        #parent_adj[node_id] = {}
        parent_adj[hex(ins)] = {}
        
        D_list, U_list = get_Defined_Used(ins)
        
        #parent_adj[node_id] = inst_info(D_list, U_list, idc.GetDisasm(ins))
        parent_adj[hex(ins)] = inst_info(D_list, U_list, idc.GetDisasm(ins))
        
        #parent_adj[node_id].parent_list.append(parent)
        parent_adj[hex(ins)].parent_list.append(parent)
        
        parent_adj[hex(ins)].node_id = node_id
        
        #parent = node_id
        parent=hex(ins)
        
        count[0] = count[0] + 1
        print("{0}".format(idc.GetDisasm(ins)))
        # add data dependency for function calls
        if check_call(ins):
            arg_list = idaapi.get_arg_addrs(ins) # returns list of addresses of args
            if arg_list != None:
                for addr in arg_list:
                    #parent_adj[node_id].data_dependence_set.add(hex(addr)) # add address here, translate to node_id while printing. The arg address may not be traversed by us at this point
                    parent_adj[hex(ins)].data_dependence_set.add(hex(addr))
            for operand in U_list:
                    op_visited = set()
                    node_addr = hex(ins)
                    dependence_set = find_data_dependence(node_addr, parent_adj, operand, op_visited)
                    #parent_adj[node_id].data_dependence_set = parent_adj[node_id].data_dependence_set.union(dependence_set)
                    parent_adj[hex(ins)].data_dependence_set = parent_adj[hex(ins)].data_dependence_set.union(dependence_set)
        else:
            stack_dependence_set = get_stack_dependence(ins, hex(ins), shadow_stack)
            if not len(stack_dependence_set) == 0:
                #parent_adj[node_id].data_dependence_set = parent_adj[node_id].data_dependence_set.union(stack_dependence_set)
                parent_adj[hex(ins)].data_dependence_set = parent_adj[hex(ins)].data_dependence_set.union(stack_dependence_set)
            else:
                for operand in U_list:
                    op_visited = set()
                    node_addr = hex(ins)
                    dependence_set = find_data_dependence(node_addr, parent_adj, operand, op_visited)
                    #parent_adj[node_id].data_dependence_set = parent_adj[node_id].data_dependence_set.union(dependence_set)
                    parent_adj[hex(ins)].data_dependence_set = parent_adj[hex(ins)].data_dependence_set.union(dependence_set)

        print("{0}      [label=\"{1}; D: {2}; U: {3} DD: {4}\"]".format(parent_adj[hex(ins)].node_id, hex(ins), D_list, U_list, parent_adj[hex(ins)].data_dependence_set))
        output_file.write("{0}      [label=\"{1}; D: {2}; U: {3} DD: {4}\"];\n".format(parent_adj[hex(ins)].node_id, hex(ins), D_list, U_list, parent_adj[hex(ins)].data_dependence_set))

    # Now call for all the successive blocks
    for succ_block in block.succs():
        #print("outside",block)
        if succ_block.start_ea not in visited:
            find_graph(succ_block, parent, visited, parent_adj, count, output_file, addr_node_id_map, shadow_stack) # recursive call
        else:
            # gets_added_in_calle_first_ins_as_parent
            ins = succ_block.start_ea
            n_id = addr_node_id_map[hex(ins)]
            parent_adj[hex(ins)].parent_list.append(parent)
    return

def print_graph(adj_parent: Dict[str, inst_info],output_file, addr_node_id_map):
    output_file.write("\n\n\n")
    for node_addr in adj_parent:
        curr_node = node_addr
        
        for dependent in adj_parent[node_addr].data_dependence_set:
            if dependent != "START" and dependent[0] != 'n':
                dependent = addr_node_id_map[dependent]
            print("{0} -> {1}".format(adj_parent[node_addr].node_id, dependent))
            output_file.write("{0} -> {1}\n".format(curr_node, dependent))
    output_file.write("\n}\n")

def main():
        print ("Start of the functions")
    #for curr_function in idautils.Functions():
        #output_dir = "DOT_FILES"
        #FUNCTION_NAME = idc.get_func_name(curr_function)
        FUNCTION_NAME = "start"
        dot_file_name = "{}.dot".format(FUNCTION_NAME)
        #with open(dot_file_name,'w') as output_file
        output_file = open(dot_file_name,'w')
        output_file.write('digraph G {\n')
        print("\nCURRENT FUNCTION IS {0}".format(FUNCTION_NAME))
        for _ in range(0,2):
            print("**********************************************")
        #FUNCTION_NAME = 'start' #Change this to whatever func you want to look for. May have to change to _start in some cases or code your own logic

        cursor = 0
        real_names = []
        addresses = []

        adj_parent : Dict[str, inst_info]= {} # hex_address-->{hex addr: inst_info}
        count = [0]
        addr_node_id_map : Dict[str,str] = {}
        names = idautils.Names()

        # Populate the two above lists with their respective data from the list of tuples returned by idautils.Names()
        for n in names:
            real_names.append(n[1]) # real_names[30] ------> addresses[30]
            addresses.append(n[0])

        # search for a 'start' name in the names list and if it is there, set cursor to the address of beginning of it
        for rn in real_names:
            if rn == FUNCTION_NAME:
                cursor = addresses[int(real_names.index(FUNCTION_NAME))]
                break

        parent="START"
        visited={}
        shadow_stack = deque()
        if cursor: #if a start was found, assign it to the cursor and then
            myFunc = idaapi.get_func(cursor)
            f = idaapi.FlowChart(myFunc)
            for block in f:
                if block.start_ea not in visited:
                    find_graph(block, parent, visited, adj_parent, count,output_file, addr_node_id_map, shadow_stack)
                    print("Disconnected blocks")

            print_graph(adj_parent,output_file, addr_node_id_map)
main()
